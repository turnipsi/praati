#!/usr/bin/perl -T
# -*- mode: perl; coding: utf-8; -*'
# $Id: praati,v 1.10 2014/02/26 20:46:54 je Exp $

=pod

A sample Apache configuration:

  PerlModule Apache::PerlRun
  PerlTaintCheck On

  # XXX why does not Files or Location work?
  <Directory /users/*/praati>
    Options +ExecCGI
    PerlHandler Apache::PerlRun
    PerlModule autodie           \
               diagnostics       \
               CGI::Pretty       \
               Class::Struct     \
               Crypt::SaltedHash \
               Data::Dumper      \
               DBD::SQLite       \
               DBI               \
               Digest::SHA       \
               Email::Valid      \
               POSIX
    PerlSendHeader On
    PerlSetVar PerlRunOnce On
    SetHandler perl-script
  </Directory>

=cut

use autodie;
use diagnostics;
use strict;
use utf8;
use warnings FATAL => qw(all);


#
# language extensions
#

package Praati {
  use Data::Dumper;
  use Exporter qw(import);

  our @EXPORT = qw(d);

  sub d { Dumper(@_); }
}


#
# configurations
#

package Praati::Config {
  Praati->import;

  our $WWW_DIR = '/'; # XXX in OpenBSD Apache chroot only...

  our $DB_DIR       = 'db';
  our $DB_FILE_PATH = "${WWW_DIR}/${DB_DIR}/praati.sqlite3";

  our $MUSIC_PATH = "${DB_DIR}/music";
}


#
# declarations (when imported into other namespaces)
#

package Praati::Controller {
  use Exporter qw(import);
  our @EXPORT = qw(html response);

  sub html;
  sub response;
}


#
# model
#

package Praati::Model {
  Praati->import;

  use Crypt::SaltedHash;
  use DBI;
  use Email::Valid;

  our $DB;

  sub init {
    my %attrs = (
      AutoCommit                       => 1,
      PrintError                       => 0,
      RaiseError                       => 1,
      sqlite_allow_multiple_statements => 1,
    );
    $DB = DBI->connect("dbi:SQLite:dbname=${Praati::Config::DB_FILE_PATH}",
		       '',
		       '',
		       \%attrs);

    $DB->do('PRAGMA foreign_keys = ON');

    Praati::Model::SQLite::register_sqlite_functions();

    create_db_tables();
  }

  sub close {
    if ($DB) { $DB->disconnect; }
  }

  sub create_db_tables {
    query(q{
      create table if not exists users (
        user_id                 integer      primary key not null,
        user_email              varchar(256) unique      not null
                                check(check_user_email(user_email)),
        user_encrypted_password varchar(256)             not null,
        user_name               varchar(256) unique      not null,
        user_role               varchar(256)             not null
                                check(user_role in ('admin', 'critic'))
      );
    });
  }

  sub query {
    my ($sql, @bind_values) = @_;
    $DB->do($sql, undef, @bind_values);
  }

  sub check_user_email {
    my ($email_address) = @_;
    Email::Valid->address($email_address) ? 1 : 0;
  }

  # XXX should you just use crypt instead?
  # XXX are blowfish passwords portable?
  # XXX how to generate salt for those?
  sub crypt_password {
    my ($password) = @_;
    my $csh = Crypt::SaltedHash->new(algorithm => 'SHA-1');
    $csh->add($password);
    $csh->generate;
  }

  sub add_new_user {
    my ($user_email, $user_name, $user_password) = @_;

    my $user_encrypted_password = crypt_password($user_password);
    my $user_role = new_user_role();

    query(q{
      insert into users (user_email,
                         user_encrypted_password,
                         user_name,
                         user_role)
        values (?, ?, ?, ?);
    }, $user_email, $user_encrypted_password, $user_name, $user_role);
  }

  sub new_user_role {
    'admin'; # XXX
  }
}

package Praati::Model::SQLite {
  Praati->import;

  sub register { $Praati::Model::DB->sqlite_create_function(@_); }

  sub register_sqlite_functions {
    register(check_user_email => 1, \&Praati::Model::check_user_email);
  }
}


#
# view
#


package Praati::View {
  Praati->import;
  Praati::Controller->import;

  BEGIN {
    my @html_funcs = qw(end_html
                        form
                        password_field
                        start_html
                        submit
                        table
                        td
                        textfield
                        Tr);

    foreach my $func (@html_funcs) {
      no strict 'refs';
      *$func = sub { html($func, @_); };
    }
  }

  sub menu {
    ''; # XXX
  }

  sub page { response(page => standard_page($_[0])); }

  sub standard_page {
    my ($content) = @_;

    start_html()
    . menu()
    . $content
    . end_html()
    . "\n";
  }

  sub maybe_error {
    my ($name, $errors, $colspan) = @_;

    defined($errors->{ $name })
      ? (td { -colspan => $colspan }, $errors->{ $name })
      : ();
  }

  #
  # pages
  #

  sub page_new_user {
    my ($errors) = @_;

    # XXX show errors
    my $tablerows = [
      maybe_error('*' => $errors, 2),

      td([ 'email address:',  textfield('user_email')               ]),
      td([ 'name:',           textfield('user_name')                ]),
      td([ 'password:',       password_field('user_password')       ]),
      td([ 'password again:', password_field('user_password_again') ]),
      td({ -colspan => 2 },
         submit(submit_new_user => 'Create new user')),
    ];

    page(
      form({ -method => 'post' },
        table(
          Tr $tablerows)));
  }
}


#
# controller
#

package Praati::Controller {
  Praati->import;

  use CGI::Pretty qw(-any);

  $CGI::Pretty::INDENT = ' ' x 2;

  our $Q;

  sub main {
    $Q = CGI->new;

    eval {
      Praati::Model::init();

      my $response = url_dispatch( $Q->path_info );

      $response->print($Q);
    };
    my $error = $@;

    Praati::Model::close();

    if ($error) {
      die $error;
    }
  }

  sub html {
    my $method = shift;
    $Q->$method(@_);
  }

  sub redirect {
    my ($path) = @_;
    response(redirect_uri => ($Q->url . $path),
             status       => 301);
  }

  sub response { Praati::Controller::Response->new(@_); }

  sub url_dispatch {
    my ($path_info) = @_;

    local $_ = $path_info;

    (
      m|^$|          ? redirect('/new_user') :
      m|^/$|         ? redirect('/new_user') :
      m|^/new_user$| ? new_user_controller() :

        no_such_page()
    );
  }

  #
  # controllers for pages
  #

  sub new_user_controller {
    my %p = $Q->Vars;
    my $errors = {};

    if ($p{submit_new_user}) {
      # XXX should check that 'user_password' and 'user_password_again' match

      eval {
        Praati::Model::add_new_user(@p{ qw(user_email
                                           user_name
                                           user_password) });
      };
      return redirect('/login') unless $@;

      $errors->{'*'} = $@; # XXX these should be handled properly
    }

    Praati::View::page_new_user($errors);
  }

  sub no_such_page {
    response(page   => 'No such page.',
             status => 404);
  }
}

package Praati::Controller::Response {
  Praati->import;

  use Class::Struct __PACKAGE__, {
    page         => '$',
    redirect_uri => '$',
    status       => '$',
  };

  sub page_with_header {
    my ($self, $q) = @_;

    my @header_args = defined($self->status)
                        ? (-status => $self->status)
                        : ();

    $q->header(@header_args)
    . $self->page;
  }

  sub print {
    my ($self, $q) = @_;

    my $content
      = defined($self->redirect_uri)
          ? $q->redirect(-status => $self->status,
                         -uri    => $self->redirect_uri)
          :
        defined($self->page)
          ? $self->page_with_header($q)
          : undef;

    die 'Not a sensible response object' unless defined $content;

    print $content;
  }
}


package main {
  Praati::Controller::main();
}
