#!/usr/bin/perl -T
# -*- mode: perl; coding: utf-8; -*'
# $Id: praati,v 1.30 2014/03/04 19:09:42 je Exp $

=pod

A sample Apache configuration:

  PerlModule Apache::PerlRun
  PerlTaintCheck On

  # XXX why does not Files or Location work?
  <Directory /users/*/praati>
    Options +ExecCGI
    PerlHandler Apache::PerlRun
    PerlModule autodie           \
               diagnostics       \
               BSD::arc4random   \
               CGI::Cookie       \
               CGI::Pretty       \
               Class::Struct     \
               Crypt::SaltedHash \
               Data::Dumper      \
               DBD::SQLite       \
               DBI               \
               Digest::SHA       \
               Email::Valid      \
               POSIX
    PerlSendHeader On
    PerlSetVar PerlRunOnce On
    SetHandler perl-script
  </Directory>

=cut

use autodie;
use diagnostics;
use strict;
use utf8;
use warnings FATAL => qw(all);


#
# language extensions
#

package Praati {
  use Data::Dumper;
  use Exporter qw(import);
  use Scalar::Util qw(blessed);

  our @EXPORT = qw(blessed d error);

  sub d { Dumper(@_); }
  sub error { die Praati::Error->new(@_); }
}

package Praati::Error {
  use Class::Struct __PACKAGE__, { message => '$', type => '$' };
}


#
# configurations
#

package Praati::Config {
  Praati->import;

  our $WWW_dir = '/'; # XXX in OpenBSD Apache chroot only...

  our $DB_dir       = 'db';
  our $DB_file_path = "${WWW_dir}/${DB_dir}/praati.sqlite3";

  our $Music_path = "${DB_dir}/music";

  our $User_session_hours = 12;
}


#
# declarations (when imported into other namespaces)
#

package Praati::Controller {
  use Exporter qw(import);
  our @EXPORT = qw(add_ui_error
                   check_user_session_key
                   query_method
                   response
                   session_user);

  sub add_ui_error;
  sub check_user_session_key;
  sub query_method;
  sub response;
  sub session_user;
}


#
# model
#

package Praati::Model {
  Praati->import;
  Praati::Controller->import;

  use Crypt::SaltedHash;
  use DBI;
  use Email::Valid;
  use Exporter qw(import);

  our @EXPORT = qw(one_value);

  our $DB;

  sub init {
    my %attrs = (
      AutoCommit                       => 1,
      PrintError                       => 0,
      RaiseError                       => 1,
      sqlite_allow_multiple_statements => 1,
    );
    $DB = DBI->connect("dbi:SQLite:dbname=${Praati::Config::DB_file_path}",
		       '',
		       '',
		       \%attrs);
    $DB->do('PRAGMA foreign_keys = ON');

    Praati::Model::SQLite::register_sqlite_functions();

    create_db_tables();
    debug_query();
    expire_old_user_sessions();
    return;
  }

  sub close {
    if ($DB) { $DB->disconnect; }
  }

  sub create_db_tables {
    query(q{
      create table if not exists users (
        user_id                 integer      primary key not null,
        user_email              varchar(256) unique      not null
                                check(check_user_email(user_email)),
        user_encrypted_password varchar(256)             not null,
        user_name               varchar(256) unique      not null,
        user_role               varchar(256)             not null
                                check(user_role in ('admin', 'critic'))
      );

      create table if not exists user_sessions (
        user_session_id         integer      primary key not null,
        user_session_expires_at timestamp    not null,
        user_session_key        varchar(256) unique not null
          check(check_user_session_key(user_session_key)),
        user_id                 integer      not null references users(user_id)
      );
    });
  }

  # DBI helpers

  sub one_value {
    my ($sql, @bind_values) = @_;
    my $columns = $DB->selectcol_arrayref($sql, {}, @bind_values);
    my $count = scalar(@$columns);

    if ($count != 1) {
      error(
        message => "Would be returning not exactly one value, but $count values",
        type    => 'not one');
    }

    $columns->[0];
  }

  sub query {
    my ($sql, @bind_values) = @_;
    $DB->do($sql, undef, @bind_values);
  }

  sub records {
    my ($key, $sql, @bind_values) = @_;
    $DB->selectall_hashref($sql, $key, undef, @bind_values);
  }

  sub rows {
    my ($sql, @bind_values) = @_;
    $DB->selectall_arrayref($sql, undef, @bind_values);
  }

  sub test { @{ rows(@_) }  >  0; }

  sub transaction {
    my ($fn) = @_;

    $DB->begin_work;

    eval {
      $fn->();
      $DB->commit;
    };
    my $db_error = $@;

    if ($db_error) {
      eval { $DB->rollback; };
      my $rollback_error = $@;

      eval {
        if ($rollback_error) {
          warn "Could not do a database rollback: $rollback_error";
        };
      };

      die $db_error;
    }
  }

  sub debug_query {
    # warn d(rows('select * from users'));
    # warn d(rows('select * from user_sessions'));
  }

  # user handling

  sub add_new_user {
    my ($errors, $user_email, $user_name, $user_password) = @_;

    my $user_encrypted_password = crypt_password($user_password);
    my $user_role               = new_user_role();

    if (not check_user_email($user_email)) {
      add_ui_error($errors, 'user_email', 'User email address is not valid.');
    }

    transaction(sub {
      if (test(q{ select user_id from users where user_email = ?; },
                $user_email)) {
        add_ui_error($errors,
                     'user_email',
                     'Email address is already reserved.');
      }

      if (test(q{ select user_id from users where user_name = ?; },
                $user_name)) {
        add_ui_error($errors, 'user_name', 'Username is already reserved.');
      }

      if (not %$errors) {
        query(q{
          insert into users (user_email,
                             user_encrypted_password,
                             user_name,
                             user_role)
            values (?, ?, ?, ?);
        }, $user_email, $user_encrypted_password, $user_name, $user_role);
      }
    });
  }

  sub check_user_email {
    my ($user_email) = @_;
    Email::Valid->address($user_email) ? 1 : 0;
  }

  # XXX should you just use crypt instead?
  # XXX are blowfish passwords portable?
  # XXX how to generate salt for those?
  sub crypt_password {
    my ($password) = @_;
    my $csh = Crypt::SaltedHash->new(algorithm => 'SHA-1');
    $csh->add($password);
    $csh->generate;
  }

  sub new_user_role {
    'admin'; # XXX
  }

  sub verify_user_password {
    my ($errors, $user_email, $user_password) = @_;

    my $salted_hash;
    eval {
      $salted_hash = one_value(q{ select user_encrypted_password from users
                                     where user_email = ?; },
                                $user_email);
    };
    my $err = $@;

    if ((blessed($err) && $err->type eq 'not one')
          or not Crypt::SaltedHash->validate($salted_hash, $user_password)) {
      add_ui_error($errors, '*', 'Wrong username or password.');
    }
  }

  # user sessions handling

  sub add_user_session {
    my ($user_email, $user_session_key) = @_;

    my $sql_hours = "+${Praati::Config::User_session_hours} hours";

    query(q{
      insert into user_sessions (user_session_expires_at,
                                 user_session_key,
                                 user_id)
        select datetime('now', ?),
               ?,
               user_id
          from users where user_email = ?;
    }, $sql_hours, $user_session_key, $user_email);
  }

  sub expire_old_user_sessions {
    query(q{ delete from user_sessions
               where user_session_expires_at < datetime('now'); });
  }

  sub find_session_user {
    my ($user_session_key) = @_;

    return if not defined $user_session_key;

    my $user_id = eval {
                    one_value(q{ select user_id from user_sessions
                                   where user_session_key = ?; },
                              $user_session_key);
                  };
    my $error = $@;

    return $user_id if not $error;

    return if blessed($error) && $error->type eq 'not one';

    warn "Unknown error in find_session_user: $error";

    return;
  }

  sub remove_user_session {
    my ($user_session_key) = @_;
    query(q{ delete from user_sessions where user_session_key = ?; },
          $user_session_key);
  }
}

package Praati::Model::SQLite {
  Praati->import;

  sub register { $Praati::Model::DB->sqlite_create_function(@_); }

  sub register_sqlite_functions {
    register('check_user_email',
             1,
             \&Praati::Model::check_user_email);

    register('check_user_session_key',
             1,
             \&Praati::Model::check_user_session_key);
  }
}


#
# view
#

package Praati::View {
  Praati->import;
  Praati::Controller->import;
  Praati::Model->import;

  BEGIN {
    my @query_methods = qw(a
                           end_html
                           form
                           meta
                           p
                           path_info
                           password_field
                           start_html
                           submit
                           table
                           td
                           textfield
                           Tr);

    foreach my $method (@query_methods) {
      no strict 'refs';
      *$method = sub { query_method($method, @_); };
    }
  }

  sub link_if_not_this_page {
    my ($target) = @_;

    my $page_descriptions = {
      login    => 'Login',
      logout   => 'Logout',
      main     => 'Main',
      new_user => 'New user',
      panels   => 'Panels',
    };

    my $description = $page_descriptions->{ $target };
    die "No page description found for $target" unless $description;

    "/$target" eq path_info()
      ? $description
      : a({ -href => link_to($target) },
          $description);
  }

  sub link_to {
    my ($target) = @_;
    my $path_depth = scalar(split(m|/|, path_info())) - 2;
    my $target_prefix = '../' x $path_depth;
    "${target_prefix}${target}";
  }

  sub menu {
    my $session_user = session_user();

    my $user_role = $session_user
                      ? one_value(q{ select user_role from users
                                       where user_id = ?; },
                                  $session_user)
                      : 'anonymous';

    my $pages_by_role = {
      admin     => [ qw(main          panels       logout) ],
      anonymous => [ qw(main new_user        login       ) ],
      critic    => [ qw(main          panels       logout) ],
    };

    my $pagelist = $pages_by_role->{ $user_role };
    die "No pagelist found for $user_role" unless $pagelist;

    table(
      Tr(
        td([ map { link_if_not_this_page($_) } @$pagelist ])));
  }

  sub page { response(page => standard_page(@_)); }

  sub standard_page {
    my ($content, %opts) = @_;

    start_html($opts{-start_html} ? @{ $opts{-start_html} } : ())
    . menu()
    . $content
    . end_html()
    . "\n";
  }

  sub maybe_error {
    my ($name, $errors, $colspan) = @_;

    defined($errors->{ $name })
      ? td({ -colspan => $colspan },
           join(' ' => @{ $errors->{ $name } }))
      : ();
  }

  #
  # pages
  #

  sub page_login {
    my ($errors, $cookie) = @_;

    my $table_width = 2;

    my $tablerows = [
      maybe_error('*' => $errors, $table_width),

      td([ 'email address:', textfield('user_email')         ]),
      td([ 'password:',      password_field('user_password') ]),

      td({ -colspan => $table_width },
         submit(submit_login => 'Login')),
    ];

    my $login_refresh_seconds
      = int($Praati::Config::User_session_hours * 60 * 60 / 2);

    # refresh every $login_refresh_seconds to get a new session cookie
    # (wipes the form as a side effect)
    my $start_html_options = [
      -head => meta({ -http_equiv => 'refresh',
                      -content    => $login_refresh_seconds }),
    ];

    my $page
      = form({ -method => 'post' },
          table(
            Tr $tablerows));

    response(cookie => $cookie,
             page   => standard_page($page,
                                     -start_html => $start_html_options));
  }

  sub page_main {
    page( p('The main page.') );
  }

  sub page_new_user {
    my ($errors) = @_;

    my $table_width = 2;

    my $tablerows = [
      maybe_error('*' => $errors, $table_width),

      maybe_error(user_email => $errors, $table_width),
      td([ 'email address:',  textfield('user_email')               ]),

      maybe_error(user_name => $errors, $table_width),
      td([ 'name:',           textfield('user_name')                ]),

      td([ 'password:',       password_field('user_password')       ]),
      td([ 'password again:', password_field('user_password_again') ]),

      td({ -colspan => $table_width },
         submit(submit_new_user => 'Create new user')),
    ];

    # XXX repetition
    page(
      form({ -method => 'post' },
        table(
          Tr $tablerows)));
  }

  sub page_logged_out {
    my ($cookie) = @_;
    response(cookie => $cookie,
             page   => standard_page( p('You are now logged out.') ));
  }

  sub page_logout_error {
    my ($errors) = @_;
    page( p('Could not log out: ' . $errors->{'*'}) );
  }

  sub page_not_logged_in {
    page( p('You are not logged in.') );
  }

  sub page_panels {
    page( p('The panels page.') );
  }
}


#
# controller
#

package Praati::Controller {
  Praati->import;

  use BSD::arc4random qw(arc4random_bytes);
  use CGI::Pretty qw(-any);

  $CGI::Pretty::INDENT = ' ' x 2;

  our ($Q, $Session_user);

  sub main {
    $Q = CGI->new;

    eval {
      Praati::Model::init();

      my $user_session_key = $Q->cookie('user_session_key');
      $Session_user = Praati::Model::find_session_user($user_session_key);

      my $response = url_dispatch( $Q->path_info );
      $response->print($Q);
    };
    my $error = $@;

    Praati::Model::close();

    if ($error) {
      die $error;
    }
  }

  sub query_method {
    my $method = shift;
    $Q->$method(@_);
  }

  sub redirect {
    my ($path) = @_;
    response(redirect_uri => ($Q->url . $path),
             status       => 301);
  }

  sub response { Praati::Controller::Response->new(@_); }

  sub url_dispatch {
    my ($path_info) = @_;

    local $_ = $path_info;

    (
      m|^$|          ? redirect('/main')     :
      m|^/$|         ? redirect('/main')     :
      m|^/login$|    ? login_controller()    :
      m|^/logout$|   ? logout_controller()   :
      m|^/main$|     ? main_controller()     : # XXX do we need this at all?
      m|^/new_user$| ? new_user_controller() :
      m|^/panels$|   ? panels_controller()   :

        no_such_page()
    );
  }

  sub add_ui_error {
    my ($errors, $field, $error_message) = @_;
    push @{ $errors->{ $field } }, $error_message;
  }

  # we do not want to show unknown error messages to users,
  # but we should log those.
  sub add_unknown_ui_error {
    my ($errors, $field, $message) = @_;
    warn "Unknown error: $message";
    add_ui_error($errors, $field, 'Unknown error');
    return;
  }

  sub check_user_session_key {
    my ($user_session_key) = @_;
    $user_session_key && $user_session_key =~ /^[0-9a-f]{40}$/;
  }

  sub session_user { $Session_user; }

  #
  # controllers for pages
  #

  sub login_controller {
    my %p = $Q->Vars;
    my $errors = {};

    return redirect('/main') if session_user();

    my $user_session_key = $Q->cookie('user_session_key');

    if ($p{submit_login}) {
      if (not check_user_session_key($user_session_key)) {
        add_ui_error($errors,
                     '*',
                     'To login, cookies must be accepted by the browser.');
      }

      eval {
        if (not %$errors) {
          Praati::Model::verify_user_password($errors,
                                              @p{ qw(user_email
                                                     user_password) });
        }
        if (not %$errors) {
          Praati::Model::add_user_session($p{user_email}, $user_session_key);
        }
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      if (not %$errors) {
        return redirect('/main');
      }
    }

    my $new_user_session_key = unpack('h*', arc4random_bytes(20));

    my $expire_hours = "+${Praati::Config::User_session_hours}h";
    my $cookie = $Q->cookie(-expires => $expire_hours,
                            -name    => 'user_session_key',
                            -value   => $new_user_session_key);

    Praati::View::page_login($errors, $cookie);
  }

  sub logout_controller {
    my $user_session_key = $Q->cookie('user_session_key');

    return Praati::View::page_not_logged_in() if not $user_session_key;

    my $errors = {};

    eval { Praati::Model::remove_user_session($user_session_key); };
    my $error = $@;

    if ($error) { add_unknown_ui_error($errors, '*', $error); }

    return Praati::View::page_logout_error($errors) if %$errors;

    # expire cookie
    my $cookie = $Q->cookie(-expires => '-1d',
                            -name    => 'user_session_key',
                            -value   => $user_session_key);

    # must set this so that view (menu generation code specifically)
    # will not think user is logged in now
    $Session_user = undef;

    Praati::View::page_logged_out($cookie);
  }

  sub main_controller {
    Praati::View::page_main();
  }

  sub new_user_controller {
    my %p = $Q->Vars;
    my $errors = {};

    if ($p{submit_new_user}) {
      if ($p{user_password} ne $p{user_password_again}) {
        add_ui_error($errors, '*', 'Passwords do not match.');
      }

      eval {
        Praati::Model::add_new_user($errors,
                                    @p{ qw(user_email
                                           user_name
                                           user_password) });
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      return redirect('/login') unless %$errors;
    }

    Praati::View::page_new_user($errors);
  }

  sub no_such_page {
    response(page   => 'No such page.',
             status => 404);
  }

  sub panels_controller {
    Praati::View::page_panels();
  }
}

package Praati::Controller::Response {
  Praati->import;

  use Class::Struct __PACKAGE__, {
    cookie       => '$',
    page         => '$',
    redirect_uri => '$',
    status       => '$',
  };

  sub page_with_header {
    my ($self, $q) = @_;

    my @header_args = (
      defined($self->cookie) ? (-cookie => $self->cookie) : (),
      defined($self->status) ? (-status => $self->status) : (),
    );

    $q->header(@header_args)
    . $self->page;
  }

  sub print {
    my ($self, $q) = @_;

    my $content
      = defined($self->redirect_uri)
          ? $q->redirect(-status => $self->status,
                         -uri    => $self->redirect_uri)
          :
        defined($self->page)
          ? $self->page_with_header($q)
          : undef;

    die 'Not a sensible response object' unless defined $content;

    print $content;
  }
}


#
# main
#

package main {
  Praati::Controller::main();
}
