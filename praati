#!/usr/bin/perl -T
# -*- mode: perl; coding: utf-8; -*-
# $Id: praati,v 1.81 2014/04/09 19:10:42 je Exp $

=pod

A sample Apache configuration:

  PerlModule Apache::PerlRun
  PerlTaintCheck On

  # XXX why does not Files or Location work?
  <Directory /users/*/praati>
    Options +ExecCGI
    PerlHandler Apache::PerlRun
    PerlModule autodie                 \
               diagnostics             \
               BSD::arc4random         \
               CGI::Carp               \
               CGI::Cookie             \
               CGI::Pretty             \
               Class::Struct           \
               Crypt::SaltedHash       \
               Data::Dumper            \
               DBD::SQLite             \
               DBI                     \
               Digest::SHA             \
               Email::Valid            \
               Encode                  \
               Encode::Unicode         \
               File::Find              \
               File::Glob              \
               List::MoreUtils         \
               Math::Trig              \
               MP3::Tag                \
               POSIX                   \
               Statistics::Descriptive \
               Tie::Hash::NamedCapture \
               URI::Escape
    PerlSendHeader On
    PerlSetVar PerlRunOnce On
    SetHandler perl-script
  </Directory>

=cut

use autodie;
# use diagnostics;
use strict;
use utf8;
use warnings FATAL => qw(all);


#
# configurations
#

package Praati::Config {
  our $WWW_dir = '/'; # XXX in OpenBSD Apache chroot only...

  our $DB_dir       = 'db';
  our $DB_file_path = "${WWW_dir}/${DB_dir}/praati.sqlite3";

  our $Music_path = "${WWW_dir}/${DB_dir}/music";

  our $User_session_hours = 12;
}


#
# constants
#

package Praati::Constants {
  # XXX database checks could also use this
  use constant MAX_SONG_RATING       => 10.0;

  use constant NO_SONG_RATING_MARKER => '-';
}

#
# errors
#

package Praati::Error {
  use Class::Struct __PACKAGE__, { message => '$', type => '$' };

  use overload q{""} => sub { $_[0]->message; };

  sub no_such_page {
    confess(
      __PACKAGE__->new(message => 'No such page',
                       type    => 'no such page'));
  }

  sub not_exactly_one {
    my ($count) = @_;
    confess(
      __PACKAGE__->new(
        message => "Would be returning not exactly one value, but $count values",
        type    => 'not one'));
  }

  sub unauthorized_access {
    confess(
      __PACKAGE__->new(message => 'User is not allowed to access this resource',
                       type    => 'unauthorized access'));
  }
}


#
# declarations (when imported into other namespaces)
#

package Praati::Controller {
  use Exporter qw(import);
  our @EXPORT = qw(add_ui_error
                   check_user_session_key
                   get_session_user_role
                   query_method
                   response
                   session_user);

  sub add_ui_error;
  sub check_user_session_key;
  sub get_session_user_role;
  sub query_method;
  sub response;
  sub session_user;
}


#
# model
#

package Praati::Model {
  Praati::Controller->import;

  use CGI::Carp;
  use Crypt::SaltedHash;
  use DBI;
  use Email::Valid;
  use Exporter qw(import);
  use File::Glob qw(bsd_glob);
  use Math::Trig;
  use Scalar::Util qw(blessed);

  our @EXPORT = qw(last_insert_id
                   one_record
                   one_value
                   query
                   records
                   records_by_key);

  our $DB;

  sub init {
    my %attrs = (
      AutoCommit                       => 1,
      PrintError                       => 0,
      RaiseError                       => 1,
      sqlite_allow_multiple_statements => 1,
    );
    $DB = DBI->connect("dbi:SQLite:dbname=${Praati::Config::DB_file_path}",
		       '',
		       '',
		       \%attrs);
    $DB->do('PRAGMA foreign_keys = ON');

    Praati::Model::SQLite::register_sqlite_functions();

    create_db_tables();
    init_db_tables();
    debug_query();
    expire_old_user_sessions();

    return;
  }

  sub close {
    if ($DB) { $DB->disconnect; }
  }

  sub create_db_tables {
    query(q{
      create table if not exists users (
        user_id                 integer      primary key not null,
        user_email              varchar(256) unique      not null
                                check(check_user_email(user_email)),
        user_encrypted_password varchar(256)             not null,
        user_name               varchar(256) unique      not null,
        user_role               varchar(256)             not null
                                check(user_role in ('admin', 'critic'))
      );

      create table if not exists user_sessions (
        user_session_id         integer      primary key not null,
        user_session_expires_at timestamp    not null,
        user_session_key        varchar(256) unique not null
          check(check_user_session_key(user_session_key)),
        user_id                 integer      not null references users(user_id)
      );

      create table if not exists panels (
        panel_id        integer      primary key not null,
        panel_musicpath varchar(256) unique not null,
        panel_name      varchar(256) unique not null
      );

      create table if not exists songs (
        song_id       integer      primary key not null,
        song_filepath varchar(256) unique not null,
        song_name     varchar(256) not null,
        artist_id     integer      not null references artists(artist_id)
      );

      create table if not exists albums (
        album_id   integer      primary key not null,
        album_name varchar(256) unique not null,
        album_year integer      not null
      );

      create table if not exists artists (
        artist_id   integer      primary key not null,
        artist_name varchar(256) unique not null
      );

      create table if not exists songs_in_albums (
        album_id     integer not null references albums(album_id),
        song_id      integer not null references songs(song_id),
        track_number integer not null,

        primary key(album_id, song_id)
      );

      create table if not exists songs_in_panels (
        album_id integer not null references albums(album_id),
        panel_id integer not null references panels(panel_id),
        song_id  integer not null references songs(song_id),

        primary key(panel_id, song_id)
      );

      create table if not exists song_ratings (
        song_rating_id      integer       primary key not null,
        song_rating_comment varchar(4096) not null,
        panel_id            integer       not null references panels(panel_id),
        song_id             integer       not null references songs(song_id),
        user_id             integer       not null references users(user_id),

        unique(panel_id, song_id, user_id)
      );

      create table if not exists song_rating_values (
        song_rating_value_id    integer    primary key not null,
        song_rating_value_value decimal(2) not null
          check(0 <= song_rating_value_value
                 and song_rating_value_value <= 10),

        song_rating_id integer unique not null
          references song_ratings(song_rating_id)
            on delete cascade
      );

      create table if not exists song_rating_normalized_values (
        song_rating_normalized_value_id    integer    primary key not null,
        song_rating_normalized_value_value decimal(5) not null
          check(0 <= song_rating_normalized_value_value
                 and song_rating_normalized_value_value <= 10),

        song_rating_value_id integer unique not null
          references song_rating_values(song_rating_value_id)
            on delete cascade
      );

      create table if not exists listening_sessions (
        listening_session_id   integer      primary key not null,
        listening_session_name varchar(256) unique not null,
        panel_id               integer      not null references panels(panel_id)
      );

      create table if not exists listening_events (
        listening_event_id     integer primary key not null,
        listening_event_number integer not null,
        listening_event_shown  integer not null,
        ls_song_position_id    integer not null
          references ls_song_positions(ls_song_position_id),

        unique(listening_event_number, ls_song_position_id)
      );

      create table if not exists ls_song_positions (
        ls_song_position_id  integer primary key not null,
        listening_session_id integer not null references
          listening_sessions(listening_session_id),
        song_id              integer not null references songs(song_id),
        song_position        integer unique not null,

        unique(listening_session_id, song_position)
      );

      create table if not exists ls_song_ratings (
        ls_song_rating_id    integer primary key not null,
        listening_session_id integer not null
          references listening_sessions(listening_session_id),
        song_rating_comment varchar(4096) not null,
        song_id             integer       not null references songs(song_id),
        user_id             integer       not null references users(user_id),

        unique(listening_session_id, song_id, user_id)
      );

      create table if not exists ls_song_rating_values (
        ls_song_rating_value_id integer primary key not null,

        song_rating_value_value decimal(2) not null
          check(0 <= song_rating_value_value
                 and song_rating_value_value <= 10),

        song_rating_normalized_value_value decimal(5) not null
          check(0 <= song_rating_normalized_value_value
                 and song_rating_normalized_value_value <= 10),

        ls_song_rating_id integer unique not null
          references ls_song_ratings(ls_song_rating_id)
            on delete cascade
      );

      -- create views

      create view if not exists songinfos
        as select * from songs
          join artists         using (artist_id)
          join songs_in_panels using (song_id)
          join songs_in_albums using (album_id, song_id)
          join albums          using (album_id);

      create view if not exists albums_in_panels
        as select distinct albums.*, songs_in_panels.panel_id
             from albums
               join songs_in_panels using (album_id);

      create view if not exists song_ratings_with_values
        as select * from song_ratings
             left outer join song_rating_values using (song_rating_id);

      create view if not exists song_ratings_with_normalized_values
        as select * from song_ratings_with_values
             left outer join song_rating_normalized_values
                               using (song_rating_value_id);

      create view if not exists user_ratings_statistics
        as select avg(song_rating_value_value)
                    as user_ratings_statistics_mean,
                  stdev(song_rating_value_value)
                    as user_ratings_statistics_stdev,
                  song_ratings_with_values.panel_id,
                  song_ratings_with_values.user_id
             from song_ratings_with_values
               where song_rating_value_value is not null
               group by panel_id, user_id;

      create view if not exists ls_song_ratings_with_sessions
        as select * from ls_song_ratings
             join listening_sessions using (listening_session_id);

      create view if not exists ls_song_ratings_with_values
        as select * from ls_song_ratings
             left outer join ls_song_rating_values using (ls_song_rating_id);

      create view if not exists ls_song_ratings_with_set_values
        as select * from ls_song_ratings_with_values
             where song_rating_value_value is not null
               and song_rating_normalized_value_value is not null;

      -- create triggers

      create trigger if not exists insert_songinfos
        instead of insert on songinfos
          begin
            insert or ignore into artists (artist_name)
              values (new.artist_name);

            insert or ignore into albums (album_name, album_year)
              values (new.album_name, new.album_year);

            -- album_name is unique
            update albums
              set album_year = max(album_year, new.album_year)
                where album_name = new.album_name;

            -- artist_name is unique
            insert into songs (song_filepath, song_name, artist_id)
              select new.song_filepath, new.song_name, artist_id
                from artists where artist_name = new.artist_name;

            -- album_name and song_filepath are unique
            insert into songs_in_albums (album_id, song_id, track_number)
              select album_id, song_id, new.track_number
                from albums join songs
                  where    album_name = new.album_name
                    and song_filepath = new.song_filepath;

            -- album_name and song_filepath are unique
            insert into songs_in_panels (album_id, panel_id, song_id)
              select album_id, new.panel_id, song_id
                from albums join songs
                  where    album_name = new.album_name
                    and song_filepath = new.song_filepath;
          end;

      create trigger if not exists insert_song_ratings_with_values
        instead of insert on song_ratings_with_values
          begin
            insert or replace into song_ratings (song_rating_comment,
                                                 panel_id,
                                                 song_id,
                                                 user_id)
              values (new.song_rating_comment,
                      new.panel_id,
                      new.song_id,
                      new.user_id);

            insert or replace into song_rating_values (song_rating_value_value,
                                                       song_rating_id)
              select new.song_rating_value_value, song_ratings.song_rating_id
                from song_ratings
                  where new.song_rating_value_value is not null
                    and song_ratings.panel_id = new.panel_id
                    and song_ratings.song_id  = new.song_id
                    and song_ratings.user_id  = new.user_id;
          end;

      create trigger if not exists delete_normalized_song_ratings
        after insert on song_rating_values
          begin
            delete from song_rating_normalized_values
              where song_rating_value_id in (
                select b.song_rating_value_id
                  from song_ratings_with_values as a
                    cross join song_ratings_with_values as b
                  where a.song_rating_id = new.song_rating_id
                    and a.panel_id       = b.panel_id
                    and a.user_id        = b.user_id
              );
          end;

    });
  }

  sub init_db_tables {
    my @musicdirs = bsd_glob("${Praati::Config::Music_path}/*");

    foreach my $musicdir (@musicdirs) {
      transaction(sub {
        my $panels
          = records(q{ select * from panels where panel_musicpath = ?; },
                    $musicdir);

        if (@$panels == 0) {
          Praati::Model::Musicscan::init_panel($musicdir);
        }
      });
    }
  }

  # DBI helpers

  sub columns {
    my ($sql, @bind_values) = @_;
    $DB->selectcol_arrayref($sql, {}, @bind_values);
  }

  sub last_insert_id { $DB->last_insert_id('', '', '', ''); }

  sub one_exactly {
    my ($values) = @_;
    my $count = scalar(@$values);

    if ($count != 1) { Praati::Error::not_exactly_one($count); }

    $values->[0];
  }

  sub one_record { one_exactly( records(@_) ); }
  sub one_value  { one_exactly( columns(@_) ); }

  sub query {
    my ($sql, @bind_values) = @_;
    $DB->do($sql, undef, @bind_values);
  }

  sub records {
    my ($sql, @bind_values) = @_;
    $DB->selectall_arrayref($sql, { Slice => {} }, @bind_values);
  }

  sub records_by_key {
    my ($key, $sql, @bind_values) = @_;
    $DB->selectall_hashref($sql, $key, undef, @bind_values);
  }

  sub test { @{ records(@_) }  >  0; }

  sub transaction {
    my ($fn) = @_;

    $DB->begin_work;

    eval {
      $fn->();
      $DB->commit;
    };
    my $db_error = $@;

    if ($db_error) {
      eval { $DB->rollback; };
      my $rollback_error = $@;

      eval {
        if ($rollback_error) {
          warn "Could not do a database rollback: $rollback_error";
        };
      };

      confess($db_error);
    }
  }

  sub debug_query {
    # use Data::Dumper;
    # warn Dumper(records(q{ select * from listening_sessions; }));
    # warn Dumper(records(q{ select * from ls_song_ratings; }));
    # warn Dumper(records(q{ select * from ls_song_rating_values; }));
  }

  #
  # user handling
  #

  sub add_new_user {
    my ($errors, $user_email, $user_name, $user_password) = @_;

    my $user_encrypted_password = crypt_password($user_password);
    my $user_role               = new_user_role();

    if (not check_user_email($user_email)) {
      add_ui_error($errors, 'user_email', 'User email address is not valid.');
    }

    transaction(sub {
      if (test(q{ select user_id from users where user_email = ?; },
                $user_email)) {
        add_ui_error($errors,
                     'user_email',
                     'Email address is already reserved.');
      }

      if (test(q{ select user_id from users where user_name = ?; },
                $user_name)) {
        add_ui_error($errors, 'user_name', 'Username is already reserved.');
      }

      if (not %$errors) {
        query(q{ insert into users (user_email,
                                    user_encrypted_password,
                                    user_name,
                                    user_role)
                   values (?, ?, ?, ?); },
              $user_email,
              $user_encrypted_password,
              $user_name,
              $user_role);
      }
    });
  }

  sub check_user_email {
    my ($user_email) = @_;
    Email::Valid->address($user_email) ? 1 : 0;
  }

  # XXX should you just use crypt instead?
  # XXX are blowfish passwords portable?
  # XXX how to generate salt for those?
  sub crypt_password {
    my ($password) = @_;
    my $csh = Crypt::SaltedHash->new(algorithm => 'SHA-1');
    $csh->add($password);
    $csh->generate;
  }

  sub new_user_role {
    # the first user created will be admin, the rest of them are merely critics
    one_value(q{ select count(user_id) from users; }) == 0
      ? 'admin'
      : 'critic';
  }

  sub verify_user_password {
    my ($errors, $user_email, $user_password) = @_;

    my $salted_hash;
    eval {
      $salted_hash = one_value(q{ select user_encrypted_password from users
                                     where user_email = ?; },
                                $user_email);
    };
    my $err = $@;

    if ((blessed($err) && $err->type eq 'not one')
          or not Crypt::SaltedHash->validate($salted_hash, $user_password)) {
      add_ui_error($errors, '*', 'Wrong username or password.');
    }
  }

  #
  # user sessions handling
  #

  sub add_user_session {
    my ($user_email, $user_session_key) = @_;

    my $sql_hours = "+${Praati::Config::User_session_hours} hours";

    query(q{ insert into user_sessions (user_session_expires_at,
                                        user_session_key,
                                        user_id)
               select datetime('now', ?),
                      ?,
                      user_id
                 from users where user_email = ?; },
          $sql_hours,
          $user_session_key,
          $user_email);
  }

  sub expire_old_user_sessions {
    query(q{ delete from user_sessions
               where user_session_expires_at < datetime('now'); });
  }

  sub find_session_user {
    my ($user_session_key) = @_;

    return if not defined $user_session_key;

    my $user_id = eval {
                    one_value(q{ select user_id from user_sessions
                                   where user_session_key = ?; },
                              $user_session_key);
                  };
    my $error = $@;

    return $user_id if not $error;

    return if blessed($error) && $error->type eq 'not one';

    warn "Unknown error in find_session_user: $error";

    return;
  }

  sub remove_user_session {
    my ($user_session_key) = @_;
    query(q{ delete from user_sessions where user_session_key = ?; },
          $user_session_key);
  }

  #
  # user ratings handling
  #

  sub cdf_normal {
    my ($mean, $stdev, $rating_value) = @_;

    $stdev = defined $stdev && $stdev > 0  ?  $stdev  :  0.00001;

    my $sum = my $value = my $x = ($rating_value - $mean) / $stdev;

    for (my $i = 1; $i <= 100; $i++) {
      $value = $value * $x * $x / (2 * $i + 1);
      $sum += $value;
    }

    0.5 + ($sum / sqrt(2 * pi)) * exp(- ($x * $x) / 2);
  }

  sub normalized_rating {
    my ($mean, $stdev, $rating_value) = @_;

    Praati::Constants::MAX_SONG_RATING
      * cdf_normal($mean, $stdev, $rating_value);
  }

  sub update_user_ratings {
    my ($panel_id, $user_id, $song_ratings) = @_;

    transaction(sub {
      my $sth = $DB->prepare(q{ insert or replace into song_ratings_with_values
                                    (song_rating_comment,
                                     song_rating_value_value,
                                     panel_id,
                                     song_id,
                                     user_id)
                                  values (?, ?, ?, ?, ?); });

      while (my ($song_id, $song_rating) = each(%$song_ratings)) {
        $sth->execute($song_rating->{rating_comment},
                      $song_rating->{rating_value},
                      $panel_id,
                      $song_id,
                      $user_id);
      }
    });
  }

  sub update_user_normalized_ratings {
    my ($panel_id, $user_id) = @_;

    query(q{
            insert into song_rating_normalized_values
                (song_rating_normalized_value_value,
                 song_rating_value_id)
              select normalized_rating(user_ratings_statistics_mean,
                                       user_ratings_statistics_stdev,
                                       song_rating_value_value),
                     song_rating_value_id
                from song_ratings_with_normalized_values
                  join user_ratings_statistics using (panel_id, user_id)
                where panel_id = ?
                  and user_id  = ?
                  and song_rating_value_value is not null
                  and song_rating_normalized_value_value is null; },
          $panel_id,
          $user_id);
  }

  #
  # listening sessions handling
  #

  sub new_listening_session {
    my ($panel, $ls_name, $ls_type, $song_position) = @_;

    transaction(sub {
      query(q{ insert into listening_sessions (listening_session_name, panel_id)
               values (?, ?); },
            $ls_name,
            $panel->{panel_id});

      my $listening_session_id = last_insert_id();

      query(q{
              insert into ls_song_ratings (listening_session_id,
                                           song_rating_comment,
                                           song_id,
                                           user_id)
                select ?, song_rating_comment, song_id, user_id
                  from song_ratings
                    where panel_id = ?; },
            $listening_session_id,
            $panel->{panel_id});

      query(q{
              insert into ls_song_rating_values
                  (song_rating_value_value,
                   song_rating_normalized_value_value,
                   ls_song_rating_id)
                select srwnv.song_rating_value_value,
                       srwnv.song_rating_normalized_value_value,
                       ls_song_ratings_with_sessions.ls_song_rating_id
                  from song_ratings_with_normalized_values as srwnv
                    cross join ls_song_ratings_with_sessions
                where srwnv.song_rating_value_value is not null
                  and srwnv.song_rating_normalized_value_value is not null
                  and ls_song_ratings_with_sessions.panel_id = srwnv.panel_id
                  and ls_song_ratings_with_sessions.song_id  = srwnv.song_id
                  and ls_song_ratings_with_sessions.user_id  = srwnv.user_id
                  and ls_song_ratings_with_sessions.listening_session_id = ?;
            },
            $listening_session_id);

      # XXX should try to get songs in winning order
      my $songs = records(q{ select * from ls_song_ratings_with_set_values
                               where listening_session_id = ?; },
                          $listening_session_id);
    });
  }
}

package Praati::Model::Musicscan {
  Praati::Model->import;

  use CGI::Carp;
  use File::Basename;
  use File::Find;
  use MP3::Tag;

  sub init_panel {
    my ($panel_musicpath) = @_;
    my $panel_name = fileparse($panel_musicpath);

    query(q{ insert into panels (panel_musicpath, panel_name) values (?, ?); },
          $panel_musicpath,
          $panel_name);

    my $panel_id = last_insert_id();
    my @mp3_filepaths = find_files(sub { /\.mp3$/ }, $panel_musicpath);

    my $sth
      = $Praati::Model::DB->prepare(q{
          insert into songinfos (artist_name,
                                 album_name,
                                 album_year,
                                 song_filepath,
                                 song_name,
                                 track_number,
                                 panel_id)
            values (?, ?, ?, ?, ?, ?, ?); });

    foreach my $mp3_filepath (@mp3_filepaths) {
      my $mp3tag = MP3::Tag->new($mp3_filepath);
      add_song($sth, $panel_id, $mp3_filepath, $mp3tag);
    }
  }

  sub find_files {
    my ($check_fn, $dir) = @_;
    my @files;
    find({ no_chdir => 1,
           wanted   => sub { push @files, $_ if $check_fn->(); } },
         $dir);
    @files;
  }

  sub add_song {
    my ($sth, $panel_id, $mp3_filepath, $mp3tag) = @_;

    foreach my $field (qw(album artist title track1 year)) {
      unless ($mp3tag->$field) {
        confess("The mp3 file $mp3_filepath is missing $field");
      }
    }

    $sth->execute($mp3tag->artist,
                  $mp3tag->album,
                  $mp3tag->year,
                  $mp3_filepath,
                  $mp3tag->title,
                  $mp3tag->track1,
                  $panel_id);
  }
}

package Praati::Model::SQLite {
  sub register_sqlite_functions {
    my $db = $Praati::Model::DB;

    $db->sqlite_create_function('check_user_email',
                                1,
                               \&Praati::Model::check_user_email);

    $db->sqlite_create_function('check_user_session_key',
                                1,
                                \&Praati::Model::check_user_session_key);

    $db->sqlite_create_function('normalized_rating',
                                3,
                                \&Praati::Model::normalized_rating);

    $db->sqlite_create_aggregate('stdev',
                                 1,
                                 'Praati::Model::SQLite::StandardDeviation');
  }
}

package Praati::Model::SQLite::StandardDeviation {
  use Statistics::Descriptive;

  sub new { bless [] => $_[0]; }

  sub step {
    my ($self, $value) = @_;
    push @$self, $value;
  }

  sub finalize {
    my ($self) = @_;
    my $stat = Statistics::Descriptive::Sparse->new();
    $stat->add_data(@$self);
    $stat->standard_deviation();
  }
}


#
# view
#

package Praati::View {
  Praati::Controller->import;
  Praati::Model->import;

  use CGI::Carp;
  use URI::Escape;
  use Scalar::Util qw(blessed);

  BEGIN {
    my @query_methods = qw(a
                           div
                           end_html
                           escapeHTML
                           form
                           h1
                           h2
                           li
                           meta
                           p
                           path_info
                           password_field
                           popup_menu
                           radio_group
                           start_html
                           submit
                           table
                           td
                           textfield
                           Tr
                           ul);

    foreach my $method (@query_methods) {
      no strict 'refs';
      *$method = sub { query_method($method, @_); };
    }
  }

  sub concat { join('' => @_); }

  sub e { escapeHTML(@_); }

  sub link_if_not_this_page {
    my ($target) = @_;

    my $page_descriptions = {
      login    => 'Login',
      logout   => 'Logout',
      main     => 'Main',
      new_user => 'New user',
      panels   => 'Panels',
    };

    my $description = $page_descriptions->{ $target };
    confess("No page description found for $target") unless $description;

    "/$target" eq path_info()
      ? $description
      : a({ -href => link_to($target) },
          $description);
  }

  sub link_to {
    my ($target) = @_;
    my $path_depth = scalar(split(m|/|, path_info())) - 2;
    my $target_prefix = '../' x $path_depth;
    "${target_prefix}${target}";
  }

  sub make_form_id {
    my ($table, $id, $field) = @_;
    "${table}[${id}].${field}";
  }

  sub menu {
    my $user_role = get_session_user_role();

    my $pages_by_role = {
      admin     => [ qw(main          panels       logout) ],
      anonymous => [ qw(main new_user        login       ) ],
      critic    => [ qw(main          panels       logout) ],
    };

    my $pagelist = $pages_by_role->{ $user_role };
    confess("No pagelist found for $user_role") unless $pagelist;

    table(
      Tr(
        td([ map { link_if_not_this_page($_) } @$pagelist ])));
  }

  sub page { response(page => standard_page(@_)); }

  sub standard_page {
    my ($title, $content, %opts) = @_;

    confess('No title set for page') unless $title;

    my @start_html_opts = (
                            $opts{-start_html} ? @{ $opts{-start_html} } : (),
                            -title => "Praati - $title",
                          );

    start_html(@start_html_opts)
    . logged_as()
    . menu()
    . $content
    . end_html()
    . "\n";
  }

  sub maybe_error {
    my ($name, $errors, $fn) = @_;

    defined($errors->{ $name })
      ? $fn->(@{ $errors->{ $name } })
      : ();
  }

  #
  # forms
  #

  sub form_new_listening_session {
    my ($errors) = @_;

    my $default_session_name = localtime();;

    my %types = (
      asc      => 'Play songs from worst to best',
      desc_asc => 'Play to the worst, then to the best from position:',
    );

    my $song_position_error = maybe_error(song_position => $errors,
                                          sub { '(' . concat(@_) . ')'; })
                                // '';

    my $type_choice
      = table(
          Tr([
               td(radio_group(listening_session_type => [ qw(asc) ],
                              'asc', '', \%types)),
               td(radio_group(listening_session_type => [ qw(desc_asc) ],
                              '', '', \%types)
                  . textfield('song_position') . $song_position_error)]));

    my $error_fn = sub { td({ -colspan => 2 }, join(' ' => @_)) };

    form({ -method => 'post' },
         table(
           Tr([
                maybe_error('*' => $errors, $error_fn),
                maybe_error(listening_session_name => $errors, $error_fn),
                td([ 'Listening session name:',
                     textfield('listening_session_name',
                               $default_session_name) ]),

                maybe_error(listening_session_type => $errors, $error_fn),
                td([ 'Select session type:', $type_choice ]),
                td({ -colspan => 2 },
                   [ submit('new_listening_session', 'Create') ])])));
  }

  sub form_panel_ratings_by_user {
    my ($panel_id, $user_id) = @_;

    my $albums = records(q{ select * from albums_in_panels where panel_id = ?
                              order by album_year; },
                         $panel_id);

    Praati::Model::update_user_normalized_ratings($panel_id, $user_id);

    my @album_rating_tables
      = map { h1(e($_->{album_name}))
              . table_album_ratings_by_user($_, $panel_id, $user_id) }
          @$albums;

    form({ -method => 'post' },
         concat(@album_rating_tables));
  }

  #
  # pages
  #

  sub page_login {
    my ($errors, $cookie) = @_;

    my $table_width = 2;
    my $error_wrapper = sub { td({ -colspan => $table_width },
                                 join(' ' => @_)); };

    my $tablerows = [
      maybe_error('*' => $errors, $error_wrapper),

      td([ 'email address:', textfield('user_email')         ]),
      td([ 'password:',      password_field('user_password') ]),

      td({ -colspan => $table_width },
         submit(submit_login => 'Login')),
    ];

    my $login_refresh_seconds
      = int($Praati::Config::User_session_hours * 60 * 60 / 2);

    # refresh every $login_refresh_seconds to get a new session cookie
    # (wipes the form as a side effect)
    my $start_html_options = [
      -head => meta({ -http_equiv => 'refresh',
                      -content    => $login_refresh_seconds }),
    ];

    my $page
      = form({ -method => 'post' },
          table(
            Tr $tablerows));

    response(cookie => $cookie,
             page   => standard_page('Login',
                                     $page,
                                     -start_html => $start_html_options));
  }

  sub page_main {
    page('Main',
         p('The main page.') );
  }

  sub page_new_user {
    my ($errors) = @_;

    my $table_width = 2;

    my $error_wrapper = sub { td({ -colspan => $table_width },
                                 join(' ' => @_)); };

    my $tablerows = [
      maybe_error('*' => $errors, $error_wrapper),

      maybe_error(user_email => $errors, $error_wrapper),
      td([ 'email address:',  textfield('user_email')               ]),

      maybe_error(user_name => $errors, $error_wrapper),
      td([ 'name:',           textfield('user_name')                ]),

      td([ 'password:',       password_field('user_password')       ]),
      td([ 'password again:', password_field('user_password_again') ]),

      td({ -colspan => $table_width },
         submit(submit_new_user => 'Create new user')),
    ];

    # XXX repetition
    my $form
      = form({ -method => 'post' },
             table(
               Tr $tablerows));

    page('Create new user', $form);
  }

  sub page_logged_out {
    my ($cookie) = @_;
    response(cookie => $cookie,
             page   => standard_page('Logged out',
                                     p('You are now logged out.')));
  }

  sub page_logout_error {
    my ($errors) = @_;
    # XXX error output to page?
    page('Logout error',
         p('Could not log out: ' . $errors->{'*'}));
  }

  sub page_new_listening_session {
    my ($errors, $panel) = @_;

    my $content
      = p(qq{Create a new listening session for panel "$panel->{panel_name}":})
        . form_new_listening_session($errors);

    page('New listening session',
         $content);
  }

  sub page_no_such_page {
    standard_page('No such page',
                  p('No such page.'));
  }

  sub page_not_logged_in {
    page('Not logged in',
         p('You are not logged in.'));
  }

  sub page_panel_ratings_by_user {
    my ($errors, $panel) = @_;

    my $panel_ratings_form = form_panel_ratings_by_user($panel->{panel_id},
                                                        session_user());

    my $content
      = p(sprintf('This panel is "%s".', e($panel->{panel_name}))
          . (maybe_error('*', $errors, sub { p(concat(@_)); }) // '')
          . $panel_ratings_form);

    page(sprintf(qq{Rate songs for "%s"}, e($panel->{panel_name})),
         $content);
  }

  sub panel_action_list_item {
    my ($panel) = @_;
    my $user_role = get_session_user_role();

    my $panel_id = uri_escape($_->{panel_id});

    my $rate_panel_uri = link_to(sprintf('panels/rate?panel_id=%d', $panel_id));

    $user_role eq 'admin'
      ? do {
          my $listening_session_uri
            = link_to(sprintf('listening_sessions/new?panel_id=%d', $panel_id));
          my $all_results_uri
            = link_to(sprintf('panels/results?panel_id=%d', $panel_id));
          sprintf('%s [%s][%s][%s]',
                  e($panel->{panel_name}),
                  a({ -href => $rate_panel_uri }, 'rate'),
                  a({ -href => $listening_session_uri },
                    'create a new listening session'),
                  a({ -href => $all_results_uri },
                    'all results'));
        }
      :
    $user_role eq 'critic'
      ? a({ -href => $rate_panel_uri }, e($panel->{panel_name}))
      :
    confess('Asking panel_action_list_item() for an unsupported role');
  }

  sub page_panels {
    my $panels = records(q{ select * from panels order by panel_name; });

    my @panel_action_items = map { panel_action_list_item($_) } @$panels;
    page('Available panels',
         p('Available panels are:') . ul( li(\@panel_action_items) ));
  }

  sub page_unauthorized_access {
    standard_page('Unauthorized access',
                  p('Access unauthorized.') );
  }

  #
  # tables
  #

  sub table_album_ratings_by_user {
    my ($album, $panel_id, $user_id) = @_;

    my $songs = records(q{ select * from songinfos
                             left outer join song_ratings_with_normalized_values
                               using (panel_id, song_id)
                           where album_id = ?
                             and panel_id = ?
                             and (user_id = ? or user_id is null)
                           order by track_number; },
                        $album->{album_id},
                        $panel_id,
                        $user_id);

    my @tablerows = map { tablerow_song_rating_by_user($_) } @$songs;

    concat( table( Tr(\@tablerows) ) );
  }

  sub tablerow_song_rating_by_user {
    my ($song_with_rating) = @_;

    my ($rating_form_id, $comment_form_id)
      = map { make_form_id(songs => $song_with_rating->{song_id}, $_) }
          qw(rating_value rating_comment);

    my $rating_choice
      = song_rating_choice($rating_form_id,
                           $song_with_rating->{song_rating_value_value});
    my $comment
      = textfield($comment_form_id,
                  $song_with_rating->{song_rating_comment} // '');

    my $normalized_value
      = $song_with_rating->{song_rating_normalized_value_value};

    my $color_for_normalized_value = color_for_rating_value($normalized_value);
    my $normalized_value_string
      = $normalized_value ? sprintf('%.1f', $normalized_value)
          : '&mdash;';

    td(e($song_with_rating->{artist_name}))
    . td(e($song_with_rating->{song_name}))
    . td($rating_choice)
    . td({ -style => "background-color: $color_for_normalized_value;" },
         $normalized_value_string)
    . td($comment)
    . td(submit(send_ratings => 'Send'));
  }

  #
  # other
  #

  sub color_for_rating_value {
    my ($rating_value) = @_;
    return '#808080' unless defined $rating_value;

    my $green
      = int(255.0 * ($rating_value / Praati::Constants::MAX_SONG_RATING));

    my $red  = int(255.0 - $green);
    my $blue = 96;

    sprintf('#%02x%02x%02x', $red, $green, $blue);
  }

  sub logged_as {
    my $user_id = session_user();

    return '' unless $user_id;

    my $user = one_record(q{ select * from users where user_id = ?; },
                          $user_id);
    $user
      ? sprintf(qq{Logged in as "%s" (%s)},
                e($user->{user_name}),
                e($user->{user_role}))
      : '';
  }

  sub song_rating_choice {
    my ($rating_form_id, $song_rating_value_value) = @_;
    my $value = defined $song_rating_value_value
                 ? sprintf('%.1f', $song_rating_value_value)
                 : Praati::Constants::NO_SONG_RATING_MARKER;

    popup_menu($rating_form_id,
               [ song_rating_values() ],
               $value);
  }

  sub song_rating_values {
    my $step_size =  0.5;

    (
      Praati::Constants::NO_SONG_RATING_MARKER,
      reverse(
        map { sprintf('%.1f', $_ * $step_size) }
          0 .. (Praati::Constants::MAX_SONG_RATING / $step_size))
    );
  }
}


#
# controller
#

package Praati::Controller {
  Praati::Model->import;

  use BSD::arc4random qw(arc4random_bytes);
  use CGI::Carp;
  use CGI::Pretty qw(-any);
  use List::MoreUtils qw(any);
  use Scalar::Util qw(blessed);

  $CGI::Pretty::INDENT = ' ' x 2;

  our ($Q, $Session_user);

  our $Debugging = 1;

  sub main {
    $Debugging
      ? debugging_wrapper(\&handle_query)
      : handle_query();
  }

  sub handle_query {
    $Q = CGI->new;

    eval {
      Praati::Model::init();

      my $user_session_key = $Q->cookie('user_session_key');
      $Session_user = Praati::Model::find_session_user($user_session_key);

      my $response = url_dispatch( $Q->path_info );
      $response->printout($Q);
    };
    my $error = $@;

    Praati::Model::close();

    if ($error) {
      confess($error);
    }
  }

  sub debugging_wrapper {
    my ($fn) = @_;

    warn "Debugging has been turned on, stacktraces end up to the browser";

    eval { $fn->() };
    my $err = $@;
    if ($err) {
      my $q = CGI->new;
      print $q->header(),
            $q->pre($err);
    }
  }

  sub query_method {
    my $method = shift;
    $Q->$method(@_);
  }

  sub redirect {
    my ($path) = @_;
    response(redirect_uri => ($Q->url . $path),
             status       => 301);
  }

  sub response { Praati::Controller::Response->new(@_); }

  sub url_dispatch {
    my ($path_info) = @_;

    local $_ = $path_info;

    my $page = eval {
      m|^$|
        ? redirect('/main')
        :
      m|^/$|
        ? redirect('/main')
        :
      m|^/listening_sessions/new$|
        ? do {
            restrict_to_roles( qw(admin) );
            new_listening_session_controller();
          }
        :
      m|^/login$|
        ? login_controller()
        :
      m|^/logout$|
        ? logout_controller()
        :
      m|^/main$|
        ? main_controller() # XXX do we need this at all?
        :
      m|^/new_user$|
        ? new_user_controller()
        :
      m|^/panels$|
        ? do {
            restrict_to_roles( qw(admin critic) );
            panels_controller();
          }
        :
      m|^/panels/rate$|
        ? do {
            restrict_to_roles( qw(admin critic) );
            panel_ratings_by_user_controller();
          }
        :
      Praati::Error::no_such_page()
    };
    my $err = $@;

    if ($err) {
      if (blessed($err)) {
        return no_such_page_controller()
          if $err->type eq 'no such page';

        return unauthorized_access_controller()
          if $err->type eq 'unauthorized access';
      }
      confess($err);
    }

    $page;
  }

  sub parse_form_ids_for_table {
    my ($table, $params) = @_;
    my %hash;

    while (my ($key, $value) = each %$params) {
      if ($key =~ /^ \Q$table\E \[(?<id>\d+)\] \. (?<field>.*) $/x) {
        $hash{ $+{id} }{ $+{field} } = $value;
      }
    }

    \%hash;
  }

  sub add_ui_error {
    my ($errors, $field, $error_message) = @_;
    push @{ $errors->{ $field } }, $error_message;
  }

  # we do not want to show unknown error messages to users,
  # but we should log those.

  sub add_unknown_ui_error {
    my ($errors, $field, $message) = @_;
    warn "Unknown error: $message";
    add_ui_error($errors, $field, 'Unknown error');
    return;
  }

  sub check_user_session_key {
    my ($user_session_key) = @_;
    $user_session_key && $user_session_key =~ /^[0-9a-f]{40}$/;
  }

  sub get_panel_by_id_or_no_such_page {
    my ($panel_id) = @_;
    my $panel = eval { one_record(q{ select * from panels where panel_id = ?; },
                                  $panel_id); };
    my $err = $@;
    if ($err) {
      Praati::Error::no_such_page() if blessed($err) && $err->type eq 'not one';
      confess($err);
    }

    $panel;
  }

  sub get_session_user_role {
    session_user()
      ? one_value(q{ select user_role from users where user_id = ?; },
                  session_user())
      : 'anonymous';
  }

  sub restrict_to_roles {
    my @roles = @_;
    my $session_user_role = get_session_user_role();

    return 1 if any(sub { $session_user_role eq $_ }, @roles);

    Praati::Error::unauthorized_access();
  }


  sub session_user { $Session_user; }

  #
  # controllers for pages
  #

  sub login_controller {
    my %p = $Q->Vars;
    my $errors = {};

    return redirect('/main') if session_user();

    my $user_session_key = $Q->cookie('user_session_key');

    if ($p{submit_login}) {
      if (not check_user_session_key($user_session_key)) {
        add_ui_error($errors,
                     '*',
                     'To login, cookies must be accepted by the browser.');
      }

      eval {
        if (not %$errors) {
          Praati::Model::verify_user_password($errors,
                                              @p{ qw(user_email
                                                     user_password) });
        }
        if (not %$errors) {
          Praati::Model::add_user_session($p{user_email}, $user_session_key);
        }
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      if (not %$errors) {
        return redirect('/main');
      }
    }

    my $new_user_session_key = unpack('h*', arc4random_bytes(20));

    my $expire_hours = "+${Praati::Config::User_session_hours}h";
    my $cookie = $Q->cookie(-expires => $expire_hours,
                            -name    => 'user_session_key',
                            -value   => $new_user_session_key);

    Praati::View::page_login($errors, $cookie);
  }

  sub logout_controller {
    my $user_session_key = $Q->cookie('user_session_key');

    return Praati::View::page_not_logged_in() if not $user_session_key;

    my $errors = {};

    eval { Praati::Model::remove_user_session($user_session_key); };
    my $error = $@;

    if ($error) { add_unknown_ui_error($errors, '*', $error); }

    return Praati::View::page_logout_error($errors) if %$errors;

    # expire cookie
    my $cookie = $Q->cookie(-expires => '-1d',
                            -name    => 'user_session_key',
                            -value   => $user_session_key);

    # must set this so that view (menu generation code specifically)
    # will not think user is logged in now
    $Session_user = undef;

    Praati::View::page_logged_out($cookie);
  }

  sub main_controller {
    Praati::View::page_main();
  }

  sub new_listening_session_controller {
    my $panel = get_panel_by_id_or_no_such_page($Q->url_param('panel_id'));

    my %p = $Q->Vars;
    my $errors = {};

    if ($p{new_listening_session}) {
      if (!$p{listening_session_name}) {
        add_ui_error($errors,
                     listening_session_name
                       => 'Listening session name is missing.');
      }

      if (!$p{listening_session_type}) {
        add_ui_error($errors,
                     listening_session_type => 'Session type is missing.');
      } elsif ($p{listening_session_type} eq 'desc_asc'
                 && (!$p{song_position} || $p{song_position} !~ /^(\d+)$/)) {
        add_ui_error($errors, song_position => 'Song position is not valid');
      }

      if (not %$errors) {
        eval {
          Praati::Model::new_listening_session($panel,
                                               @p{ qw(listening_session_name
                                                      listening_session_type
                                                      song_position) });
        };
        if ($@) { add_unknown_ui_error($errors, '*', $@); }

        return redirect('/XXX') unless %$errors;
      }
    }

    Praati::View::page_new_listening_session($errors, $panel);
  }

  sub new_user_controller {
    my %p = $Q->Vars;
    my $errors = {};

    if ($p{submit_new_user}) {
      if (not $p{user_password}) {
        add_ui_error($errors, user_password => 'Password is missing.');
      }
      if (not $p{user_password_again}) {
        add_ui_error($errors, user_password_again => 'Password is missing.');
      }
      if ($p{user_password} && $p{user_password_again}
            && $p{user_password} ne $p{user_password_again}) {
        add_ui_error($errors, '*', 'Passwords do not match.');
      }

      eval {
        Praati::Model::add_new_user($errors,
                                    @p{ qw(user_email
                                           user_name
                                           user_password) });
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      return redirect('/login') unless %$errors;
    }

    Praati::View::page_new_user($errors);
  }

  sub no_such_page_controller {
    response(page   => Praati::View::page_no_such_page(),
             status => 404);
  }

  sub panel_ratings_by_user_controller {
    my $panel = get_panel_by_id_or_no_such_page($Q->url_param('panel_id'));

    my %p = $Q->Vars;
    my $errors = {};

    if ($p{send_ratings}) {
      my $song_ratings = parse_form_ids_for_table(songs => \%p);
      while (my ($song_id, $rating) = each %$song_ratings) {
        if ($rating->{ rating_value }
              eq Praati::Constants::NO_SONG_RATING_MARKER) {
          $song_ratings->{ $song_id }{ rating_value } = undef;
        }
      }

      eval {
        Praati::Model::update_user_ratings($panel->{panel_id},
                                           session_user(),
                                           $song_ratings);
      };
      if ($@) {
        add_unknown_ui_error($errors, '*', $@);
      }
    }

    Praati::View::page_panel_ratings_by_user($errors, $panel);
  }

  sub panels_controller {
    Praati::View::page_panels();
  }

  sub unauthorized_access_controller {
    response(page   => Praati::View::page_unauthorized_access(),
             status => 403);
  }
}

package Praati::Controller::Response {
  use Class::Struct __PACKAGE__, {
    cookie       => '$',
    page         => '$',
    redirect_uri => '$',
    status       => '$',
  };

  sub page_with_header {
    my ($self, $q) = @_;

    my @header_args = (
      defined($self->cookie) ? (-cookie => $self->cookie) : (),
      defined($self->status) ? (-status => $self->status) : (),
    );

    $q->header(@header_args)
    . $self->page;
  }

  sub printout {
    my ($self, $q) = @_;

    my $content
      = defined($self->redirect_uri)
          ? $q->redirect(-status => $self->status,
                         -uri    => $self->redirect_uri)
          :
        defined($self->page)
          ? $self->page_with_header($q)
          : undef;

    confess('Not a sensible response object') unless defined $content;

    print $content;
  }
}


#
# main
#

package main {
  Praati::Controller::main();
}
