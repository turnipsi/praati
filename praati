#!/usr/bin/perl -T
# -*- mode: perl; coding: utf-8; -*'
# $Id: praati,v 1.34 2014/03/08 11:08:24 je Exp $

=pod

A sample Apache configuration:

  PerlModule Apache::PerlRun
  PerlTaintCheck On

  # XXX why does not Files or Location work?
  <Directory /users/*/praati>
    Options +ExecCGI
    PerlHandler Apache::PerlRun
    PerlModule autodie           \
               diagnostics       \
               BSD::arc4random   \
               CGI::Cookie       \
               CGI::Pretty       \
               Class::Struct     \
               Crypt::SaltedHash \
               Data::Dumper      \
               DBD::SQLite       \
               DBI               \
               Digest::SHA       \
               Email::Valid      \
               Encode            \
               Encode::Unicode   \
               File::Find        \
               File::Glob        \
               MP3::Tag          \
               POSIX
    PerlSendHeader On
    PerlSetVar PerlRunOnce On
    SetHandler perl-script
  </Directory>

=cut

use autodie;
use diagnostics;
use strict;
use utf8;
use warnings FATAL => qw(all);


#
# language extensions
#

package Praati {
  use Data::Dumper;
  use Exporter qw(import);
  use File::Find;
  use Scalar::Util qw(blessed);

  our @EXPORT = qw(blessed d error find_files);

  sub d { Dumper(@_); }
  sub error { die Praati::Error->new(@_); }

  sub find_files {
    my ($check_fn, $dir) = @_;
    my @files;
    find({ no_chdir => 1,
           wanted   => sub { push @files, $_ if $check_fn->(); } },
         $dir);
    @files;
  }
}

package Praati::Error {
  use Class::Struct __PACKAGE__, { message => '$', type => '$' };
}


#
# configurations
#

package Praati::Config {
  Praati->import;

  our $WWW_dir = '/'; # XXX in OpenBSD Apache chroot only...

  our $DB_dir       = 'db';
  our $DB_file_path = "${WWW_dir}/${DB_dir}/praati.sqlite3";

  our $Music_path = "${WWW_dir}/${DB_dir}/music";

  our $User_session_hours = 12;
}


#
# declarations (when imported into other namespaces)
#

package Praati::Controller {
  use Exporter qw(import);
  our @EXPORT = qw(add_ui_error
                   check_user_session_key
                   query_method
                   response
                   session_user);

  sub add_ui_error;
  sub check_user_session_key;
  sub query_method;
  sub response;
  sub session_user;
}


#
# model
#

package Praati::Model {
  Praati->import;
  Praati::Controller->import;

  use Crypt::SaltedHash;
  use DBI;
  use Email::Valid;
  use Exporter qw(import);
  use File::Glob qw(bsd_glob);

  our @EXPORT = qw(last_insert_id one_value query records rows);

  our $DB;

  sub init {
    my %attrs = (
      AutoCommit                       => 1,
      PrintError                       => 0,
      RaiseError                       => 1,
      sqlite_allow_multiple_statements => 1,
    );
    $DB = DBI->connect("dbi:SQLite:dbname=${Praati::Config::DB_file_path}",
		       '',
		       '',
		       \%attrs);
    $DB->do('PRAGMA foreign_keys = ON');

    Praati::Model::SQLite::register_sqlite_functions();

    create_db_tables();
    init_db_tables();
    debug_query();
    expire_old_user_sessions();

    return;
  }

  sub close {
    if ($DB) { $DB->disconnect; }
  }

  sub create_db_tables {
    query(q{
      create table if not exists users (
        user_id                 integer      primary key not null,
        user_email              varchar(256) unique      not null
                                check(check_user_email(user_email)),
        user_encrypted_password varchar(256)             not null,
        user_name               varchar(256) unique      not null,
        user_role               varchar(256)             not null
                                check(user_role in ('admin', 'critic'))
      );

      create table if not exists user_sessions (
        user_session_id         integer      primary key not null,
        user_session_expires_at timestamp    not null,
        user_session_key        varchar(256) unique not null
          check(check_user_session_key(user_session_key)),
        user_id                 integer      not null references users(user_id)
      );

      create table if not exists panels (
        panel_id        integer      primary key not null,
        panel_musicpath varchar(256) unique not null,
        panel_name      varchar(256) unique not null
      );

      create table if not exists songs (
        song_id       integer      primary key not null,
        song_filepath varchar(256) unique not null,
        song_name     varchar(256) not null,
        artist_id     integer      not null references artists(artist_id)
      );

      create table if not exists albums (
        album_id   integer      primary key not null,
        album_name varchar(256) unique not null,
        album_year integer      not null
      );

      create table if not exists artists (
        artist_id   integer      primary key not null,
        artist_name varchar(256) unique not null
      );

      create table if not exists songs_in_album (
        album_id     integer not null references albums(album_id),
        song_id      integer not null references songs(song_id),
        track_number integer not null,

        primary key(album_id, song_id)
      );

      create table if not exists songs_in_panel (
        album_id integer not null references albums(album_id),
        panel_id integer not null references panels(panel_id),
        song_id  integer not null references songs(song_id),

        primary key(panel_id, song_id)
      );

      create table if not exists song_ratings (
        song_rating_id      integer       primary key not null,
        song_rating_comment varchar(4096) not null,
        song_id             integer       not null references songs(song_id),
        user_id             integer       not null references users(user_id),

        unique(song_id, user_id)
      );

      create table if not exists song_rating_values (
        song_rating_value_id    integer    primary key not null,
        song_rating_value_value decimal(2) not null
          check(                                  0 <= song_rating_value_value
                and         song_rating_value_value <= 10
                and (song_rating_value_value % 0.5) == 0),

        song_rating_id integer unique not null
          references song_ratings(song_rating_id)
      );

      -- create views

      create view if not exists songinfos
        as select * from songs
          join artists        using (artist_id)
          join songs_in_panel using (song_id)
          join songs_in_album using (album_id, song_id)
          join albums         using (album_id);

      create view if not exists song_ratings_with_values
        as select * from song_rating_values
          join song_ratings using (song_rating_id);

      -- create triggers

      create trigger if not exists insert_songinfos
        instead of insert on songinfos
          begin
            insert or ignore into artists (artist_name)
              values (new.artist_name);

            insert or ignore into albums (album_name, album_year)
              values (new.album_name, new.album_year);

            -- album_name is unique
            update albums
              set album_year = max(album_year, new.album_year)
                where album_name = new.album_name;

            -- artist_name is unique
            insert into songs (song_filepath, song_name, artist_id)
              select new.song_filepath, new.song_name, artist_id
                from artists where artist_name = new.artist_name;

            -- album_name and song_filepath are unique
            insert into songs_in_album (album_id, song_id, track_number)
              select album_id, song_id, new.track_number
                from albums join songs
                  where    album_name = new.album_name
                    and song_filepath = new.song_filepath;

            -- album_name and song_filepath are unique
            insert into songs_in_panel (album_id, panel_id, song_id)
              select album_id, new.panel_id, song_id
                from albums join songs
                  where    album_name = new.album_name
                    and song_filepath = new.song_filepath;
          end;
    });
  }

  sub init_db_tables {
    my @musicdirs = bsd_glob("${Praati::Config::Music_path}/*");

    foreach my $musicdir (@musicdirs) {
      transaction(sub {
        my $panels = rows(q{ select * from panels where panel_musicpath = ?; },
                          $musicdir);

        if (@$panels == 0) {
          Praati::Model::Musicscan::init_panel($musicdir);
        }
      });
    }
  }

  # DBI helpers

  sub last_insert_id { $DB->last_insert_id('', '', '', ''); }

  sub one_value {
    my ($sql, @bind_values) = @_;
    my $columns = $DB->selectcol_arrayref($sql, {}, @bind_values);
    my $count = scalar(@$columns);

    if ($count != 1) {
      error(
        message => "Would be returning not exactly one value, but $count values",
        type    => 'not one');
    }

    $columns->[0];
  }

  sub query {
    my ($sql, @bind_values) = @_;
    $DB->do($sql, undef, @bind_values);
  }

  sub records {
    my ($key, $sql, @bind_values) = @_;
    $DB->selectall_hashref($sql, $key, undef, @bind_values);
  }

  sub rows {
    my ($sql, @bind_values) = @_;
    $DB->selectall_arrayref($sql, { Slice => {} }, @bind_values);
  }

  sub test { @{ rows(@_) }  >  0; }

  sub transaction {
    my ($fn) = @_;

    $DB->begin_work;

    eval {
      $fn->();
      $DB->commit;
    };
    my $db_error = $@;

    if ($db_error) {
      eval { $DB->rollback; };
      my $rollback_error = $@;

      eval {
        if ($rollback_error) {
          warn "Could not do a database rollback: $rollback_error";
        };
      };

      die $db_error;
    }
  }

  sub debug_query {
    # warn d(rows('select * from albums'));
  }

  # user handling

  sub add_new_user {
    my ($errors, $user_email, $user_name, $user_password) = @_;

    my $user_encrypted_password = crypt_password($user_password);
    my $user_role               = new_user_role();

    if (not check_user_email($user_email)) {
      add_ui_error($errors, 'user_email', 'User email address is not valid.');
    }

    transaction(sub {
      if (test(q{ select user_id from users where user_email = ?; },
                $user_email)) {
        add_ui_error($errors,
                     'user_email',
                     'Email address is already reserved.');
      }

      if (test(q{ select user_id from users where user_name = ?; },
                $user_name)) {
        add_ui_error($errors, 'user_name', 'Username is already reserved.');
      }

      if (not %$errors) {
        query(q{
          insert into users (user_email,
                             user_encrypted_password,
                             user_name,
                             user_role)
            values (?, ?, ?, ?);
        }, $user_email, $user_encrypted_password, $user_name, $user_role);
      }
    });
  }

  sub check_user_email {
    my ($user_email) = @_;
    Email::Valid->address($user_email) ? 1 : 0;
  }

  # XXX should you just use crypt instead?
  # XXX are blowfish passwords portable?
  # XXX how to generate salt for those?
  sub crypt_password {
    my ($password) = @_;
    my $csh = Crypt::SaltedHash->new(algorithm => 'SHA-1');
    $csh->add($password);
    $csh->generate;
  }

  sub new_user_role {
    'admin'; # XXX
  }

  sub verify_user_password {
    my ($errors, $user_email, $user_password) = @_;

    my $salted_hash;
    eval {
      $salted_hash = one_value(q{ select user_encrypted_password from users
                                     where user_email = ?; },
                                $user_email);
    };
    my $err = $@;

    if ((blessed($err) && $err->type eq 'not one')
          or not Crypt::SaltedHash->validate($salted_hash, $user_password)) {
      add_ui_error($errors, '*', 'Wrong username or password.');
    }
  }

  # user sessions handling

  sub add_user_session {
    my ($user_email, $user_session_key) = @_;

    my $sql_hours = "+${Praati::Config::User_session_hours} hours";

    query(q{
      insert into user_sessions (user_session_expires_at,
                                 user_session_key,
                                 user_id)
        select datetime('now', ?),
               ?,
               user_id
          from users where user_email = ?;
    }, $sql_hours, $user_session_key, $user_email);
  }

  sub expire_old_user_sessions {
    query(q{ delete from user_sessions
               where user_session_expires_at < datetime('now'); });
  }

  sub find_session_user {
    my ($user_session_key) = @_;

    return if not defined $user_session_key;

    my $user_id = eval {
                    one_value(q{ select user_id from user_sessions
                                   where user_session_key = ?; },
                              $user_session_key);
                  };
    my $error = $@;

    return $user_id if not $error;

    return if blessed($error) && $error->type eq 'not one';

    warn "Unknown error in find_session_user: $error";

    return;
  }

  sub remove_user_session {
    my ($user_session_key) = @_;
    query(q{ delete from user_sessions where user_session_key = ?; },
          $user_session_key);
  }
}

package Praati::Model::Musicscan {
  Praati->import;
  Praati::Model->import;

  use File::Basename;
  use MP3::Tag;

  sub init_panel {
    my ($panel_musicpath) = @_;
    my $panel_name = fileparse($panel_musicpath);

    query(q{ insert into panels (panel_musicpath, panel_name) values (?, ?); },
          $panel_musicpath,
          $panel_name);

    my $panel_id = last_insert_id();
    my @mp3_filepaths = find_files(sub { /\.mp3$/ }, $panel_musicpath);

    foreach my $mp3_filepath (@mp3_filepaths) {
      my $mp3tag = MP3::Tag->new($mp3_filepath);
      add_song($panel_id, $mp3_filepath, $mp3tag);
    }
  }

  sub add_song {
    my ($panel_id, $mp3_filepath, $mp3tag) = @_;

    foreach my $field (qw(album artist title track1 year)) {
      unless ($mp3tag->$field) {
        die "The mp3 file $mp3_filepath is missing $field";
      }
    }

    query(q{
            insert into songinfos (artist_name,
                                   album_name,
                                   album_year,
                                   song_filepath,
                                   song_name,
                                   track_number,
                                   panel_id)
              values (?, ?, ?, ?, ?, ?, ?);
          },
          $mp3tag->artist,
          $mp3tag->album,
          $mp3tag->year,
          $mp3_filepath,
          $mp3tag->title,
          $mp3tag->track1,
          $panel_id);
  }
}

package Praati::Model::SQLite {
  Praati->import;

  sub register { $Praati::Model::DB->sqlite_create_function(@_); }

  sub register_sqlite_functions {
    register('check_user_email',
             1,
             \&Praati::Model::check_user_email);

    register('check_user_session_key',
             1,
             \&Praati::Model::check_user_session_key);
  }
}


#
# view
#

package Praati::View {
  Praati->import;
  Praati::Controller->import;
  Praati::Model->import;

  BEGIN {
    my @query_methods = qw(a
                           end_html
                           form
                           li
                           meta
                           p
                           path_info
                           password_field
                           start_html
                           submit
                           table
                           td
                           textfield
                           Tr
                           ul);

    foreach my $method (@query_methods) {
      no strict 'refs';
      *$method = sub { query_method($method, @_); };
    }
  }

  sub link_if_not_this_page {
    my ($target) = @_;

    my $page_descriptions = {
      login    => 'Login',
      logout   => 'Logout',
      main     => 'Main',
      new_user => 'New user',
      panels   => 'Panels',
    };

    my $description = $page_descriptions->{ $target };
    die "No page description found for $target" unless $description;

    "/$target" eq path_info()
      ? $description
      : a({ -href => link_to($target) },
          $description);
  }

  sub link_to {
    my ($target) = @_;
    my $path_depth = scalar(split(m|/|, path_info())) - 2;
    my $target_prefix = '../' x $path_depth;
    "${target_prefix}${target}";
  }

  sub menu {
    my $session_user = session_user();

    my $user_role = $session_user
                      ? one_value(q{ select user_role from users
                                       where user_id = ?; },
                                  $session_user)
                      : 'anonymous';

    my $pages_by_role = {
      admin     => [ qw(main          panels       logout) ],
      anonymous => [ qw(main new_user        login       ) ],
      critic    => [ qw(main          panels       logout) ],
    };

    my $pagelist = $pages_by_role->{ $user_role };
    die "No pagelist found for $user_role" unless $pagelist;

    table(
      Tr(
        td([ map { link_if_not_this_page($_) } @$pagelist ])));
  }

  sub page { response(page => standard_page(@_)); }

  sub standard_page {
    my ($content, %opts) = @_;

    start_html($opts{-start_html} ? @{ $opts{-start_html} } : ())
    . menu()
    . $content
    . end_html()
    . "\n";
  }

  sub maybe_error {
    my ($name, $errors, $colspan) = @_;

    defined($errors->{ $name })
      ? td({ -colspan => $colspan },
           join(' ' => @{ $errors->{ $name } }))
      : ();
  }

  #
  # pages
  #

  sub page_login {
    my ($errors, $cookie) = @_;

    my $table_width = 2;

    my $tablerows = [
      maybe_error('*' => $errors, $table_width),

      td([ 'email address:', textfield('user_email')         ]),
      td([ 'password:',      password_field('user_password') ]),

      td({ -colspan => $table_width },
         submit(submit_login => 'Login')),
    ];

    my $login_refresh_seconds
      = int($Praati::Config::User_session_hours * 60 * 60 / 2);

    # refresh every $login_refresh_seconds to get a new session cookie
    # (wipes the form as a side effect)
    my $start_html_options = [
      -head => meta({ -http_equiv => 'refresh',
                      -content    => $login_refresh_seconds }),
    ];

    my $page
      = form({ -method => 'post' },
          table(
            Tr $tablerows));

    response(cookie => $cookie,
             page   => standard_page($page,
                                     -start_html => $start_html_options));
  }

  sub page_main {
    page( p('The main page.') );
  }

  sub page_new_user {
    my ($errors) = @_;

    my $table_width = 2;

    my $tablerows = [
      maybe_error('*' => $errors, $table_width),

      maybe_error(user_email => $errors, $table_width),
      td([ 'email address:',  textfield('user_email')               ]),

      maybe_error(user_name => $errors, $table_width),
      td([ 'name:',           textfield('user_name')                ]),

      td([ 'password:',       password_field('user_password')       ]),
      td([ 'password again:', password_field('user_password_again') ]),

      td({ -colspan => $table_width },
         submit(submit_new_user => 'Create new user')),
    ];

    # XXX repetition
    page(
      form({ -method => 'post' },
        table(
          Tr $tablerows)));
  }

  sub page_logged_out {
    my ($cookie) = @_;
    response(cookie => $cookie,
             page   => standard_page( p('You are now logged out.') ));
  }

  sub page_logout_error {
    my ($errors) = @_;
    page( p('Could not log out: ' . $errors->{'*'}) );
  }

  sub page_not_logged_in {
    page( p('You are not logged in.') );
  }

  sub page_panels {
    my $panels = rows(q{ select * from panels order by panel_name; });

    my @items = map {
                  my $link = link_to('panels/' . $_->{panel_id});
                  a({ -href => $link }, $_->{panel_name});
                } @$panels;

    page(
      p('Available panels are:')
      . ul( li(\@items) ));
  }
}


#
# controller
#

package Praati::Controller {
  Praati->import;

  use BSD::arc4random qw(arc4random_bytes);
  use CGI::Pretty qw(-any);

  $CGI::Pretty::INDENT = ' ' x 2;

  our ($Q, $Session_user);

  sub main {
    $Q = CGI->new;

    eval {
      Praati::Model::init();

      my $user_session_key = $Q->cookie('user_session_key');
      $Session_user = Praati::Model::find_session_user($user_session_key);

      my $response = url_dispatch( $Q->path_info );
      $response->print($Q);
    };
    my $error = $@;

    Praati::Model::close();

    if ($error) {
      die $error;
    }
  }

  sub query_method {
    my $method = shift;
    $Q->$method(@_);
  }

  sub redirect {
    my ($path) = @_;
    response(redirect_uri => ($Q->url . $path),
             status       => 301);
  }

  sub response { Praati::Controller::Response->new(@_); }

  sub url_dispatch {
    my ($path_info) = @_;

    local $_ = $path_info;

    (
      m|^$|          ? redirect('/main')     :
      m|^/$|         ? redirect('/main')     :
      m|^/login$|    ? login_controller()    :
      m|^/logout$|   ? logout_controller()   :
      m|^/main$|     ? main_controller()     : # XXX do we need this at all?
      m|^/new_user$| ? new_user_controller() :
      m|^/panels$|   ? panels_controller()   :

        no_such_page()
    );
  }

  sub add_ui_error {
    my ($errors, $field, $error_message) = @_;
    push @{ $errors->{ $field } }, $error_message;
  }

  # we do not want to show unknown error messages to users,
  # but we should log those.
  sub add_unknown_ui_error {
    my ($errors, $field, $message) = @_;
    warn "Unknown error: $message";
    add_ui_error($errors, $field, 'Unknown error');
    return;
  }

  sub check_user_session_key {
    my ($user_session_key) = @_;
    $user_session_key && $user_session_key =~ /^[0-9a-f]{40}$/;
  }

  sub session_user { $Session_user; }

  #
  # controllers for pages
  #

  sub login_controller {
    my %p = $Q->Vars;
    my $errors = {};

    return redirect('/main') if session_user();

    my $user_session_key = $Q->cookie('user_session_key');

    if ($p{submit_login}) {
      if (not check_user_session_key($user_session_key)) {
        add_ui_error($errors,
                     '*',
                     'To login, cookies must be accepted by the browser.');
      }

      eval {
        if (not %$errors) {
          Praati::Model::verify_user_password($errors,
                                              @p{ qw(user_email
                                                     user_password) });
        }
        if (not %$errors) {
          Praati::Model::add_user_session($p{user_email}, $user_session_key);
        }
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      if (not %$errors) {
        return redirect('/main');
      }
    }

    my $new_user_session_key = unpack('h*', arc4random_bytes(20));

    my $expire_hours = "+${Praati::Config::User_session_hours}h";
    my $cookie = $Q->cookie(-expires => $expire_hours,
                            -name    => 'user_session_key',
                            -value   => $new_user_session_key);

    Praati::View::page_login($errors, $cookie);
  }

  sub logout_controller {
    my $user_session_key = $Q->cookie('user_session_key');

    return Praati::View::page_not_logged_in() if not $user_session_key;

    my $errors = {};

    eval { Praati::Model::remove_user_session($user_session_key); };
    my $error = $@;

    if ($error) { add_unknown_ui_error($errors, '*', $error); }

    return Praati::View::page_logout_error($errors) if %$errors;

    # expire cookie
    my $cookie = $Q->cookie(-expires => '-1d',
                            -name    => 'user_session_key',
                            -value   => $user_session_key);

    # must set this so that view (menu generation code specifically)
    # will not think user is logged in now
    $Session_user = undef;

    Praati::View::page_logged_out($cookie);
  }

  sub main_controller {
    Praati::View::page_main();
  }

  sub new_user_controller {
    my %p = $Q->Vars;
    my $errors = {};

    if ($p{submit_new_user}) {
      if ($p{user_password} ne $p{user_password_again}) {
        add_ui_error($errors, '*', 'Passwords do not match.');
      }

      eval {
        Praati::Model::add_new_user($errors,
                                    @p{ qw(user_email
                                           user_name
                                           user_password) });
      };
      if ($@) { add_unknown_ui_error($errors, '*', $@); }

      return redirect('/login') unless %$errors;
    }

    Praati::View::page_new_user($errors);
  }

  sub no_such_page {
    response(page   => 'No such page.',
             status => 404);
  }

  sub panels_controller {
    Praati::View::page_panels();
  }
}

package Praati::Controller::Response {
  Praati->import;

  use Class::Struct __PACKAGE__, {
    cookie       => '$',
    page         => '$',
    redirect_uri => '$',
    status       => '$',
  };

  sub page_with_header {
    my ($self, $q) = @_;

    my @header_args = (
      defined($self->cookie) ? (-cookie => $self->cookie) : (),
      defined($self->status) ? (-status => $self->status) : (),
    );

    $q->header(@header_args)
    . $self->page;
  }

  sub print {
    my ($self, $q) = @_;

    my $content
      = defined($self->redirect_uri)
          ? $q->redirect(-status => $self->status,
                         -uri    => $self->redirect_uri)
          :
        defined($self->page)
          ? $self->page_with_header($q)
          : undef;

    die 'Not a sensible response object' unless defined $content;

    print $content;
  }
}


#
# main
#

package main {
  Praati::Controller::main();
}
